#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright (c) 2024-2025 Beartype authors.
# See "LICENSE" for further details.

'''
Beartype-specific **fixture type-checkers** (i.e., high-level factory functions
creating and returning closures wrapping the passed :mod:`pytest` fixtures with
:mod:`beartype`-backed type-checking).
'''

# ....................{ IMPORTS                            }....................
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# CAUTION: Importing from the external "beartype" package is acceptable *ONLY*
# from within this subpackage.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
from beartype import beartype
from beartype.roar import BeartypeException
from collections.abc import Callable
from functools import wraps

# ....................{ CLASSES                            }....................
@beartype
class BeartypeFixtureFailure(object):
    '''
    **Fixture failure** (i.e., placeholder object wrapping a :mod:`pytest`
    fixture that violated one or more :mod:`beartype`-backed type-checks with
    details describing that violation).
    '''

    # ....................{ DUNDERS                        }....................
    def __init__(self, fixture_name: str, fixture_exception: Exception) -> None:
        '''
        Initialize this fixture failure.

        Parameters
        ----------
        fixture_name : str
            Fully-qualified name of the fixture that failed.
        fixture_exception : Exception
            Exception raised by beartype-based type-checking of this fixture.
        '''

        # Classify all passed parameters.
        self.fixture_name = fixture_name
        self.fixture_exception = fixture_exception

# ....................{ DECORATORS ~ sync                  }....................
@beartype
def beartype_fixture_sync_nongenerator(
    fixture_func: Callable, fixture_name: str) -> Callable:
    '''
    Custom :mod:`beartype` decorator unique to :mod:`pytest` synchronous
    non-generator fixtures, dynamically generating and returning a new
    :func:`beartype.beartype`-decorated synchronous non-generator fixture
    function wrapping the passed synchronous non-generator fixture function with
    type-checking.

    Parameters
    ----------
    fixture_func : Callable
        Low-level pure-Python function implementing this high-level fixture.
    fixture_name : str
        Fully-qualified name of this fixture.
    '''
    assert callable(fixture_func), f'{repr(fixture_func)} uncallable.'
    assert isinstance(fixture_name, str), f'{repr(fixture_name)} not string.'

    # Attempt to..
    try:
        # Function wrapping this fixture function with type-checking dynamically
        # generated by @beartype.
        fixture_func_checked = beartype(fixture_func)

        @wraps(fixture_func)
        def _beartype_fixture_wrapper(*args, **kwargs):
            f'''
            :func:`beartype.beartype`-decorated fixture function wrapping the
            original "{fixture_func.__qualname__}" fixture with type-checking.
            '''

            # Attempt to defer to this type-checked fixture function wrapper.
            try:
                return fixture_func_checked(*args, **kwargs)
            # If doing so raises a @beartype-specific call-time exception (e.g.,
            # due to type-checking violation), squelch this exception and return
            # a placeholder object encapsulating this exception instead.
            except BeartypeException as exception:
                return BeartypeFixtureFailure(fixture_name, exception)
    # If doing so raises a @beartype-specific decoration-time exception (e.g.,
    # due to a PEP-noncompliant type hint), squelch this exception and replace
    # the original fixture with a wrapper unconditionally returning a
    # placeholder object encapsulating this exception whenever called.
    except BeartypeException as exception:
        @wraps(fixture_func)
        def _beartype_fixture_wrapper(
            *args, __beartype_exception__=exception, **kwargs):
            f'''
            Wrapper unconditionally returning a placeholder object encapsulating
            a decoration-time exception raised by the :func:`beartype.beartype`
            decorator on decorating the original "{fixture_func.__qualname__}"
            fixture with type-checking.

            Note that this exception is intentionally passed as a hidden
            optional ``__beartype_exception__`` parameter to this fixture
            wrapper. Why? Because if we do *not* do that, then CPython complains
            that the ``__beartype_exception__`` attribute is inaccessible to the
            body of this closure. Why? No idea. Closure mechanics frighten me,
            honestly:

                NameError: cannot access free variable '__beartype_exception__'
                where it is not associated with a value in enclosing scope
            '''

            # Return a placeholder object encapsulating this exception.
            return BeartypeFixtureFailure(fixture_name, __beartype_exception__)

    # Return this @beartype-decorated fixture wrapper.
    return _beartype_fixture_wrapper


@beartype
def beartype_fixture_sync_generator(
    fixture_func: Callable, fixture_name: str) -> Callable:
    '''
    Custom :mod:`beartype` decorator unique to :mod:`pytest` synchronous
    generator fixtures, dynamically generating and returning a new
    :func:`beartype.beartype`-decorated synchronous generator fixture function
    wrapping the passed synchronous generator fixture function with
    type-checking.

    Parameters
    ----------
    fixture_func : Generator
        Low-level pure-Python generator implementing this high-level fixture.
    fixture_name : str
        Fully-qualified name of this fixture.
    '''
    assert callable(fixture_func), f'{repr(fixture_func)} uncallable.'
    assert isinstance(fixture_name, str), f'{repr(fixture_name)} not string.'

    # Attempt to..
    try:
        # Function wrapping this fixture generator with type-checking dynamically
        # generated by @beartype.
        fixture_func_checked = beartype(fixture_func)

        @wraps(fixture_func)
        def _beartype_fixture_wrapper(*args, **kwargs):
            f'''
            :func:`beartype.beartype`-decorated fixture generator wrapping the
            original "{fixture_func.__qualname__}" fixture with type-checking.
            '''

            # Attempt to defer to this type-checked fixture function wrapper.
            try:
                yield from fixture_func_checked(*args, **kwargs)
            # If doing so raises a @beartype-specific call-time exception (e.g.,
            # due to type-checking violation), squelch this exception and yield
            # a placeholder object encapsulating this exception instead.
            except BeartypeException as exception:
                yield BeartypeFixtureFailure(fixture_name, exception)
    # If doing so raises a @beartype-specific decoration-time exception (e.g.,
    # due to a PEP-noncompliant type hint), squelch this exception and replace
    # the original fixture with a wrapper unconditionally yielding a placeholder
    # object encapsulating this exception whenever called.
    except BeartypeException as exception:
        @wraps(fixture_func)
        def _beartype_fixture_wrapper(
            *args, __beartype_exception__=exception, **kwargs):
            f'''
            Wrapper unconditionally yielding a placeholder object encapsulating
            a decoration-time exception raised by the :func:`beartype.beartype`
            decorator on decorating the original "{fixture_func.__qualname__}"
            fixture with type-checking.

            See Also
            --------
            :func:`._beartype_fixture_sync_generator`
                Further details.
            '''

            # Yield a placeholder object encapsulating this exception.
            yield BeartypeFixtureFailure(fixture_name, __beartype_exception__)

    # Return this @beartype-decorated fixture wrapper.
    return _beartype_fixture_wrapper

# ....................{ DECORATORS ~ async                  }....................
@beartype
def beartype_fixture_async(
    fixture_func: Callable, fixture_name: str) -> Callable:
    '''
    Custom :mod:`beartype` decorator unique to :mod:`pytest` asynchronous
    fixtures, dynamically generating and returning a new
    :func:`beartype.beartype`-decorated asynchronous fixture function wrapping
    the passed asynchronous fixture function with type-checking.

    Note that this decorator transparently handles both:

    * **Fixture coroutines** (i.e., asynchronous non-generator functions).
    * **Fixture asynchronous generators.**

    Why? Because the low-level ``await`` keyboard supported *only* in
    **asynchronous functions** (i.e., coroutines and asynchronous generators) is
    simply syntactic sugar that sorta reduces to just ``yield from``. Unlike
    with the distinction between synchronous non-generators (which are
    prohibited from calling ``yield from``) and synchronous generators (which
    are permitted to call ``yield from``), asynchronous non-generators and
    generators are both permitted to (and, indeed, *must*) call ``await``.
    Moreover, asynchronous non-generators and generators are both prohibited
    from calling ``yield from``. CPython raises a fatal :exc:`SyntaxError` at
    importation time for *any* submodule attempting to define such a function.

    Parameters
    ----------
    fixture_func : Callable
        Low-level pure-Python function implementing this high-level fixture.
    fixture_name : str
        Fully-qualified name of this fixture.
    '''
    assert callable(fixture_func), f'{repr(fixture_func)} uncallable.'
    assert isinstance(fixture_name, str), f'{repr(fixture_name)} not string.'

    # Attempt to..
    try:
        # Function wrapping this fixture function with type-checking dynamically
        # generated by @beartype.
        fixture_func_checked = beartype(fixture_func)

        @wraps(fixture_func)
        async def _beartype_fixture_wrapper(*args, **kwargs):
            f'''
            :func:`beartype.beartype`-decorated fixture function wrapping the
            original "{fixture_func.__qualname__}" fixture with type-checking.
            '''

            # Attempt to defer to this type-checked fixture function wrapper.
            try:
                return await fixture_func_checked(*args, **kwargs)
            # If doing so raises a @beartype-specific call-time exception (e.g.,
            # due to type-checking violation), squelch this exception and return
            # a placeholder object encapsulating this exception instead.
            except BeartypeException as exception:
                return BeartypeFixtureFailure(fixture_name, exception)
    # If doing so raises a @beartype-specific decoration-time exception (e.g.,
    # due to a PEP-noncompliant type hint), squelch this exception and replace
    # the original fixture with a wrapper unconditionally returning a
    # placeholder object encapsulating this exception whenever called.
    except BeartypeException as exception:
        # Defer asyncio-specific imports as late as feasible.
        from asyncio import sleep as asyncio_sleep

        @wraps(fixture_func)
        async def _beartype_fixture_wrapper(
            *args, __beartype_exception__=exception, **kwargs):
            f'''
            Wrapper unconditionally returning a placeholder object encapsulating
            a decoration-time exception raised by the :func:`beartype.beartype`
            decorator on decorating the original "{fixture_func.__qualname__}"
            fixture with type-checking.

            Note that this exception is intentionally passed as a hidden
            optional ``__beartype_exception__`` parameter to this fixture
            wrapper. Why? Because if we do *not* do that, then CPython complains
            that the ``__beartype_exception__`` attribute is inaccessible to the
            body of this closure. Why? No idea. Closure mechanics frighten me,
            honestly:

                NameError: cannot access free variable '__beartype_exception__'
                where it is not associated with a value in enclosing scope
            '''

            # Silently reduce to an asynchronous noop. *ALL* coroutines are
            # required to call the "await" keyword at least once. Since the
            # placeholder object returned below is synchronous and thus *CANNOT*
            # be asynchronously awaited, this fallback wrapper has *NO* recourse
            # but to asynchronously await a minimal-cost awaitable. Aaaaaaand...
            #
            # This is why the "asyncio" API is Python's most hated. We sigh!
            await asyncio_sleep(0)

            # Return a placeholder object encapsulating this exception.
            return BeartypeFixtureFailure(fixture_name, __beartype_exception__)

    # Return this @beartype-decorated fixture wrapper.
    return _beartype_fixture_wrapper
